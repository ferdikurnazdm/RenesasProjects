#include "hal_data.h"
#include "common_data.h"
#include "uart_code.h"
#include "smith_prothocol.h"
#include "timer_code.h"
#include "calculate.h"
#include "r_ioport_cfg.h"
#include "r_sci_uart_cfg.h"
#include "r_sci_uart.h"
#include "r_ioport.h"
#include "r_uart_api.h"
#include "r_ioport_api.h"
#include "bsp_pin_cfg.h"
#include "bsp_api.h"
//---------------------------------------------------------------------//
fsp_err_t status;
bsp_io_level_t p_level;
int reset_status = 1;
int size_of_array = 0;
int q1_result;
int q2_result;
int buf_comp_0 = (500);
int buf_comp_1 = (500);
//uint8_t ek_response[] = {'0', '0', '0', '0', '0', '0', '0'};
//uint8_t response[] = "Q1XXXXXX";
uint8_t total_q1[11]  = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
uint8_t total_q2[11]  = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
unsigned char arr_unsigned_base[11] = {0X02,'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
//--------------------------------------------------------------------//
void ex_handle(fsp_err_t state);
void total_q1_clear();
void total_q2_clear();


FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER
/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/




void hal_entry(void)
{
    status = uart_init();
    ex_handle(status);
    status = gpt0_init();
    ex_handle(status);
    status = gpt1_init();
    ex_handle(status);
    R_BSP_SoftwareDelay(250, BSP_DELAY_UNITS_MILLISECONDS);
    status = uart_write_banner();
    ex_handle(status);
    R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
    uint32_t gpt_desired_u_sec = (uint32_t)hz_to_usec(2775);
    uint32_t calculated_period = period_calculate(gpt_desired_u_sec);
    gpt_update_period_for_q1(calculated_period);
    gpt_update_period_for_q2(calculated_period);
    while(1) {
        status = R_IOPORT_PinRead(&g_ioport_ctrl, BOARD_ACTIVATE, &p_level);
        R_BSP_SoftwareDelay(50, BSP_DELAY_UNITS_MILLISECONDS);
        if ((p_level) == BSP_IO_LEVEL_HIGH) {
            if (reset_status == 2) { // ==1 olacak
                gpt_desired_u_sec = (uint32_t)hz_to_usec(2775);
                calculated_period = period_calculate(gpt_desired_u_sec);
                gpt_update_period_for_q1(calculated_period);
                gpt_update_period_for_q2(calculated_period);
                gpt0_start();
                gpt1_start();
            }
            uint8_t * p_received_data = uart_read();
            R_BSP_SoftwareDelay(10, BSP_DELAY_UNITS_MILLISECONDS);
            int etx_index = check_smith_format(p_received_data);
            if (etx_index != -1) {
                unsigned char leaved_lrc = split_lrc(p_received_data, etx_index);
                size_of_array =  get_array_size();
                get_etx_index(p_received_data, size_of_array);
                unsigned char * p_converted_unsigned_char_data = convert_unsigned_char(p_received_data);
                int j = 1;
                for (j = 1; j < etx_index; ++j) {
                    arr_unsigned_base[j] = (unsigned char) *(p_converted_unsigned_char_data + j);
                }
                arr_unsigned_base[etx_index] = (unsigned char)(0x03);
                //R_BSP_SoftwareDelay(50, BSP_DELAY_UNITS_MILLISECONDS);
                if (ıs_lrc_valid(leaved_lrc, &arr_unsigned_base[1],etx_index)) {
                    uint8_t * p_salt_data = get_salt_data(p_received_data);
                    int key = command_router(p_salt_data);
                    if (key != -1) {
                        switch (key) {
                            case 0:
                                q1_result = q1_command_check(p_salt_data);
                                if (q1_result == 0) {
                                    uint8_t * p_meaningful_data = get_meaningful_data();
                                    int value = array_to_int(p_meaningful_data);
                                    if (value != buf_comp_0 && value != '\0') {
                                        uint64_t converted_hertz = debi_to_hertz(value);
                                        if (converted_hertz == (uint64_t)(-1)) {
                                            gpt0_stop();
                                        }
                                        else {
                                            reset_status = 0;
                                            gpt_desired_u_sec = (uint32_t)hz_to_usec(converted_hertz);
                                            calculated_period = period_calculate(gpt_desired_u_sec);
                                            gpt_update_period_for_q1(calculated_period);
                                            int gpt0_state = gpt_timer0_state();
                                            if (gpt0_state != 1) {
                                                gpt0_start();
                                            }
                                            buf_comp_0 = value;
                                        }
                                        //------------SEND SMITH PROTHOCOL METHOD------------//
                                        //uint8_t * P_converted_uint8_command = create_special_command();
                                        set_command_size();
                                        unsigned char * p_created_command = create_command();
                                        uint8_t * P_converted_uint8_command = convert_to_uint8(p_created_command);
                                        //total_q1_clear();
                                        for (size_t i = 0; i < 11; ++i) {
                                            total_q1[i] = *(P_converted_uint8_command + i);
                                        }
                                        R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
                                        status = uart_write(total_q1); //lrc ıs true;
                                        ex_handle(status);
                                    }
                                }
                                break;
                            case 1:
                                R_BSP_SoftwareDelay(50, BSP_DELAY_UNITS_MILLISECONDS);
                                status = uart_write(total_q1); //lrc ıs true;
                                ex_handle(status);
                                break;
                            case 2:
                                ///  LOOK HERE AGAIN FOR EK COMMAND.
                                if (1) {
                                    unsigned char * ek_command = send_ek_response(p_salt_data, reset_status);
                                    status = uart_write(ek_command);
                                }
                                break;
                            case 3:
                                q2_result = q2_command_check(p_salt_data);
                                if (q2_result == 0) {
                                    uint8_t * p_meaningful_data = get_meaningful_data();
                                    int value = array_to_int(p_meaningful_data);
                                    if (value != buf_comp_1 && value != '\0'){
                                        uint64_t converted_hertz = debi_to_hertz(value);
                                        if (converted_hertz == (uint64_t)(-1)) {
                                            gpt1_stop();
                                        }
                                        else {
                                            reset_status = 0;
                                            gpt_desired_u_sec = (uint32_t)hz_to_usec(converted_hertz);
                                            calculated_period = period_calculate(gpt_desired_u_sec);
                                            gpt_update_period_for_q2(calculated_period);
                                            int gpt1_state = gpt_timer1_state();
                                            if (gpt1_state != 1) {
                                                gpt1_start();
                                            }
                                            buf_comp_1 = value;
                                            //--------------------------------------------------------//
                                            set_command_size();
                                            unsigned char * p_created_command = create_command();
                                            uint8_t * P_converted_uint8_command = convert_to_uint8(p_created_command);
                                            total_q2_clear();
                                            for (size_t i = 0; i < 11; ++i) {
                                                total_q2[i] = *(P_converted_uint8_command + i);
                                            }
                                            R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
                                            status = uart_write(total_q2); //lrc ıs true;

                                            ex_handle(status);
                                        }
                                    }
                                }
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
        }
        else {
            gpt0_stop();
            gpt1_stop();
            reset_status = 1;
            // buf_comp değeri ayarlanabilir
        }















            //int num=_array_to_int_(foo);
            //if (num!=buf_comp)
            //{
             //   gpt_desired_u_sec=(uint32_t)_hz_to_usec_(num);
             //   calculated_per=_period_calc_(gpt_desired_u_sec);
             //   _gpt_update_period_(calculated_per);
             //   buf_comp=num;
            //}

        }









    /* TODO: add your own code here */
#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif



/////////////////// - MY METHODS - /////////////////////////////////

/* Callback function */
void uart_callback(uart_callback_args_t *p_args)
{
    (void)p_args;
    /* TODO: add your own code here */
}

/* Callback function
void uart_callback(uart_callback_args_t *p_args) {
    (void)p_args;
    // TODO: add your own code here
}*/

void ex_handle(fsp_err_t state) {
    if (state != FSP_SUCCESS) {
        R_IOPORT_PinWrite(&g_ioport_ctrl, RED_ALARM_LED, BSP_IO_LEVEL_HIGH);
    }

    else {
        R_IOPORT_PinWrite(&g_ioport_ctrl, RED_ALARM_LED, BSP_IO_LEVEL_LOW);
    }
}

void total_q1_clear(){
    for (size_t i = 0; i < 11; ++i) {
        total_q1[i] = '\0';
    }
}

void total_q2_clear(){
    for (size_t i = 0; i < 11; ++i) {
        total_q2[i] = '\0';
    }
}
