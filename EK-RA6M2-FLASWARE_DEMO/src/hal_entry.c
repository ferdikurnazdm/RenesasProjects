#include "hal_data.h"
#include "common_data.h"
#include "uart_code.h"
#include "smith_prothocol.h"
#include "timer_code.h"
#include "calculate.h"
#include "r_ioport_cfg.h"
#include "r_sci_uart_cfg.h"
#include "r_sci_uart.h"
#include "r_ioport.h"
#include "r_uart_api.h"
#include "r_ioport_api.h"
#include "bsp_pin_cfg.h"
#include "bsp_api.h"
//---------------------------------------------------------------------//
fsp_err_t status;
bsp_io_level_t p_level;
int reset_status = 1;
int size_of_array = 0;
int q1_result;
int buf_comp = (500);
uint8_t ek_response[] = {'0', '0', '0', '0', '0', '0', '0'};
uint8_t response[] = "Q1XXXXXX";
uint8_t total[11] = {'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
unsigned char arr_unsigned_base[11] = {0X02,'\0','\0','\0','\0','\0','\0','\0','\0','\0','\0'};
//--------------------------------------------------------------------//
void ex_handle(fsp_err_t state);




FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    status = uart_init();
    ex_handle(status);
    status = gpt_init();
    ex_handle(status);
    R_BSP_SoftwareDelay(250, BSP_DELAY_UNITS_MILLISECONDS);
    status = uart_write_banner();
    ex_handle(status);
    R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
    uint32_t gpt_desired_u_sec = (uint32_t)hz_to_usec(1389);
    uint32_t calculated_period = period_calculate(gpt_desired_u_sec);
    gpt_update_period(calculated_period);

    while(1) {
        status = R_IOPORT_PinRead(&g_ioport_ctrl, BOARD_ACTIVATE, &p_level);
        if ((p_level) == BSP_IO_LEVEL_HIGH) {
            uint8_t * p_received_data = uart_read();
                    R_BSP_SoftwareDelay(1000, BSP_DELAY_UNITS_MILLISECONDS);
                    int etx_index = check_smith_format(p_received_data);
                    if (etx_index != -1) {
                        unsigned char leaved_lrc = split_lrc(p_received_data, etx_index);
                        size_of_array =  get_array_size();
                        get_etx_index(p_received_data, size_of_array);
                        unsigned char * p_converted_unsigned_char_data = convert_unsigned_char(p_received_data);
                        int j = 1;
                        for (j = 1; j < etx_index; ++j) {
                            arr_unsigned_base[j] = (unsigned char) *(p_converted_unsigned_char_data + j);
                        }
                        arr_unsigned_base[etx_index] = (unsigned char)(0x03);
                        R_BSP_SoftwareDelay(50, BSP_DELAY_UNITS_MILLISECONDS);
                        if (ıs_lrc_valid(leaved_lrc, &arr_unsigned_base[1],etx_index)) {
                            uint8_t * p_salt_data = get_salt_data(p_received_data);
                            int key = command_router(p_salt_data);
                            if (key != -1) {
                                switch (key) {
                                    case 0:
                                        q1_result = q1_command_check(p_salt_data);
                                        if (q1_result == 0) {
                                            uint8_t * p_meaningful_data = get_meaningful_data();
                                            int value = array_to_int(p_meaningful_data);
                                            if (value != buf_comp && value != '\0') {
                                                uint64_t converted_hertz = debi_to_hertz(value);
                                                if (converted_hertz == (uint64_t)(-1)) {
                                                    uart_stop();
                                                }
                                                else {
                                                    reset_status = 0;
                                                    gpt_desired_u_sec = (uint32_t)hz_to_usec(converted_hertz);
                                                    calculated_period = period_calculate(gpt_desired_u_sec);
                                                    gpt_update_period(calculated_period);
                                                    uart_start();
                                                    buf_comp = value;
                                                }
                                                //------------SEND SMITH PROTHOCOL METHOD------------//
                                                //uint8_t * P_converted_uint8_command = create_special_command();
                                                set_command_size();
                                                unsigned char * p_created_command = create_command();
                                                uint8_t * P_converted_uint8_command = convert_to_uint8(p_created_command);
                                                for (size_t i = 0; i < 11; ++i) {
                                                    total[i] = *(P_converted_uint8_command + i);
                                                }
                                                R_BSP_SoftwareDelay(50, BSP_DELAY_UNITS_MILLISECONDS);
                                                status = uart_write(total); //lrc ıs true;
                                            }
                                        }
                                        break;
                                    case 1:
                                        R_BSP_SoftwareDelay(50, BSP_DELAY_UNITS_MILLISECONDS);
                                        status = uart_write(total); //lrc ıs true;
                                        break;
                                    case 2:
                                        if (reset_status == 0) {
                                            ek_response[6] = '0';
                                        }
                                        else {
                                            ek_response[6] = '1';
                                        }
                                        status = uart_write(ek_response);
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
        }
        else {
            uart_stop();
        }















        /*int num=_array_to_int_(foo);
        if (num!=buf_comp)
        {
            gpt_desired_u_sec=(uint32_t)_hz_to_usec_(num);
            calculated_per=_period_calc_(gpt_desired_u_sec);
            _gpt_update_period_(calculated_per);
            buf_comp=num;
        }*/

    }
    /* TODO: add your own code here */

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}















/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}
#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif


/////////////////// - MY METHODS - /////////////////////////////////


/* Callback function */
void uart_callback(uart_callback_args_t *p_args) {
    (void)p_args;
    /* TODO: add your own code here */
}

void ex_handle(fsp_err_t state) {
    if (state != FSP_SUCCESS) {
        R_IOPORT_PinWrite(&g_ioport_ctrl, RED_ALARM_LED, BSP_IO_LEVEL_HIGH);
    }

    else {
        R_IOPORT_PinWrite(&g_ioport_ctrl, RED_ALARM_LED, BSP_IO_LEVEL_LOW);
    }
}





